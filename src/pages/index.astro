---

// Imports

import PMCF from '../layouts/PMCF.astro';
import { getCollection, getEntries, getEntry } from 'astro:content';
import {Image} from 'astro:assets';

// Content

const preface = await getCollection('pmcf');
const intro = await getEntry('extra', 'pmcf-intro');
const {Content} = await intro.render();

---

<PMCF title={intro.data.title} description={intro.body}>
	<div id="vscroll">
		<header>
			<div class="reel">
				<div class="description card">
					<h1>{intro.data.title}</h1>
					<Content />
				</div>
			</div>
		</header>
		{preface.map(async (preface) => {
			const {Content} = await preface.render();
			const relatedPosts = await getEntries(preface.data.relatedPosts);
			return (
				<section>
					<button class="nav next" aria-label="Previous slide">←</button>
        			<button class="nav prev" aria-label="Next slide">→</button>
					<div class="reel">
						<div class="description card">
							<Content />
						</div>
						{relatedPosts.map(relatedPost => (
							<article class="link card">
								<a href=`/${relatedPost.collection}/${relatedPost.slug}`>
									<Image src={relatedPost.data.cover} alt={relatedPost.data.coverAlt} width="200" />
									{relatedPost.data.title}
								</a>
							</article>
						))}
					</div>
				</section>
			)}
		)}
	</div>
</PMCF>

<style is:global>

:root {

	/* Slide defs */

	--slideMargin: calc(var(--s4p) + 4vw);
	--slideMarginTotal: calc(var(--slideMargin) * 2);
	--slidePadding: calc(var(--slideMargin) * 1.5);
	--slidePaddingTotal: calc(var(--slidePadding) * 2);
	
	/* Slide Description specifics */

	--slideDescWidth: calc(100vw - (var(--slideMargin) * 2) - (var(--slidePadding) * 2) - var(--scrollbarWidth));
	--slideDescContentWidth: calc(20em + 40vw);
}

/* Layout */

/* #vscroll {
	height: 100vh;
	height: 100dvh;
	overflow-x: hidden;
    overflow-y: auto;
    scroll-snap-type: y mandatory;
}
#vscroll > * {
    scroll-snap-align: start;
} */
.reel {
	display: flex;
	align-items: center;
	overflow-x: auto;
	overflow-y: hidden;
	scroll-snap-type: x mandatory;
	scroll-snap-stop: always;
	scrollbar-width: none;
}
.reel::-webkit-scrollbar {
	display: none;
}

/* Card Component */

.card {
	scroll-snap-align: center;
	flex-shrink: 0;
	display: flex;
	flex-direction: column;
	justify-content: center;
	box-sizing: content-box;
	margin: var(--slideMargin) 0;
    border-radius: var(--slidePadding);
	overflow: hidden;
	background-color: #ddd; /* Temp */
}
.description.card {
	width: var(--slideDescWidth);
	max-width: var(--slideDescContentWidth);
	min-height: 20em;
	height: calc(30em + 30vw);
    max-height: calc(100vh - var(--slideMarginTotal) - var(--slidePaddingTotal));
    max-height: calc(100dvh - var(--slideMarginTotal) - var(--slidePaddingTotal));
	padding: var(--slidePadding);
	margin-left: var(--slideMargin);
}
@media (min-width: 53em) {
	.reel .card:first-child {
		margin-left: calc((100vw - var(--slideDescContentWidth) - var(--slidePaddingTotal) - var(--scrollbarWidth)) / 2);
	}
	.reel .card:last-child {
		margin-right: calc((100vw - var(--slideDescContentWidth) - var(--slidePaddingTotal) - var(--scrollbarWidth)) / 2);
	}
}

/* Card Content */

.card *:nth-child(1) {
	margin-top: 0;
}
.card *:nth-last-child(1) {
	margin-bottom: 0;
}

</style>

<script>

// Previous/Next buttons for reels

function initializeButtonFunctionality() {
    document.querySelectorAll('.nav.prev, .nav.next').forEach(button => {
        button.addEventListener('click', () => {
            let sibling = button.nextElementSibling;
            while (sibling && !sibling.classList.contains('reel')) {
                sibling = sibling.nextElementSibling;
            }
            if (sibling && sibling.classList.contains('reel')) {
                const direction = button.classList.contains('next') ? -1 : 1;
                scrollToCard(sibling, direction);
            }
        });
    });
}
const scrollToCard = (reel: Element, direction: number) => {
    const cards = reel.querySelectorAll('.card');
    const currentScrollPosition = reel.scrollLeft;
    const cardWidth = cards.length ? (cards[0] as HTMLElement).offsetWidth : 0;
    const newScrollPosition = currentScrollPosition + cardWidth * direction;
    reel.scroll({
        left: newScrollPosition,
        behavior: 'smooth'
    });
};
document.addEventListener('DOMContentLoaded', initializeButtonFunctionality);

</script>