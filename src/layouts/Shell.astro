---
const { title, description, customClass } = Astro.props;
---
<html lang="en" class={ customClass }>
<head>
	<title>{ title }</title>
	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#242630">
	<meta name="msapplication-TileColor" content="#f8f8f7">
	<meta name="theme-color" content="#f8f8f7">
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<meta name="generator" content={ Astro.generator } />
	<meta name="description" content={ description }>
	<meta property="og:image" content="/meta.png" />
</head>
<body>
	<div class="preloader">
		<div class="anim"></div>
	</div>
	<slot />
</body>
</html>
<style is:global>
@font-face {
	font-family: "LexendDeca";
	src:
		url("/fonts/LexendDeca.woff2") format("woff2 supports variations"),
		url("/fonts/LexendDeca.woff2") format("woff2-variations");
	font-weight: 100 1000;
	font-display: swap;
}
@font-face {
	font-family: "LexendPeta";
	src:
		url("/fonts/LexendPeta.woff2") format("woff2 supports variations"),
		url("/fonts/LexendPeta.woff2") format("woff2-variations");
	font-weight: 100 1000;
	font-display: swap;
}
@font-face {
	font-family: "Whiteboard";
	/* src: url("/fonts/whiteboardbeta.otf") format("opentype"); */
	src: url("/fonts/whiteboardbeta.woff2") format("woff2");
	font-weight: 400;
	font-display: swap;
	font-variant-ligatures: common-ligatures;
}
:root {
	/* Colors */
	--paper: #F8F8F7;
	--paper-fade: rgba(248, 248, 247, 0.5);
	--charcoal: #242630;
	--charcoal-fade: #4a4c58;
	--black-light: rgba(0, 0, 0, 0.07);
	--black-fade: rgba(0, 0, 0, 0.2);
	--black-medium: rgba(0, 0, 0, 0.4);
	--black-strong: rgba(0, 0, 0, 0.8);
	--white: white;
	--white-light: rgba(255, 255, 255, 0.12);
	--stickie-yellow: #ffe38c;
	--yellow-fade: rgba(255, 227, 140, 0.25);
	--stickie-blue: #c1edfc;
	--blue-fade: rgba(193, 237, 252, 0.25);
	--stickie-green: #d0f580;
	--green-fade: rgba(208, 245, 128, 0.25);
	--stickie-pink: #ffdadf;
	--pink-fade: rgba(255, 218, 223, 0.25);
	/* Form */
	--sa: 0.03125rem;
	--sb: 0.0625rem;
	--sc: 0.1875rem;
	--sd: 0.3125rem;
	--se: 0.5rem;
	--sf: 0.8125rem;
	--shadow-a: var(--black-fade) 0 0.125rem 0 0;
	--shadow-b: var(--black-light) 0 0.5rem 0 0;
	/* Whiteboard grid control */
	--maxcol-01: 17em;
	--maxcol-02: calc(var(--maxcol-01) * 2 + 1em);
	--maxcol-03: calc(var(--maxcol-01) * 3 + 2em);
	--maxcol-04: calc(var(--maxcol-01) * 4 + 3em);
	--maxcol-05: calc(var(--maxcol-01) * 5 + 4em);
	--maxcol-06: calc(var(--maxcol-01) * 6 + 5em);
	--maxcol-07: calc(var(--maxcol-01) * 7 + 6em);
	/* Layering system */
	--l-overlay: 1;
	--l-overlap: 2;
	--l-float: 4;
	--l-modality: 8;
	--l-system: 16;
}
html {
	font-family: "LexendDeca", system-ui, sans-serif;
	font-size: 16px;
	font-weight: 350;
	line-height: 150%;
	color: var(--charcoal);
	background-color: var(--paper);
	cursor: url(/artwork/default.svg) 7 1, auto;
}
html, body {
	overflow: hidden;
}
html.index :not(a):not(input):not(textarea):not(button):not(button *):not(abbr[aria-label]):not(img:hover):not([video]):not(video) {
	cursor: url(/artwork/grab.svg) 12 12, grab;
}
p, h1, h2, h3, h4, h5, h6, ul, ol, li, input, textarea {
	cursor: url(/artwork/text.svg) 12 12, text;
}
a:link, button, input[type="submit"], input[type="button"], input[type="reset"], select, [video] {
	cursor: url(/artwork/pointer.svg) 7 4, pointer;
}
p img:hover {
	cursor: url(/artwork/eye.svg) 12 12, auto;
}
body, h1, h2, h3, h4, h5, p, ul {
	margin: 0;
}
h1, h2 {
	font-weight: 650;
	font-size: 3em;
	line-height: 83%;
	letter-spacing: -0.03125em;
	text-transform: uppercase;
	overflow-wrap: break-word;
}
h1, h2, p, li {
    hyphens: auto;
}
h3 {
	font-weight: 550;
	font-size: 1.5em;
	line-height: 133%;
}
h4, h5 {
	font-family: "LexendPeta";
	font-weight: 750;
	font-size: 0.75em;
	line-height: 133%;
	text-transform: uppercase;
}
p {
	font-size: 1em;
	line-height: 150%;
}
ul {
	padding-left: 1.5em;
}
a, a:visited {
	color: inherit;
	overflow-wrap: break-word;
	border-radius: var(--sa);
}
a:hover {
	color: var(--black-medium);
}
a:active {
	color: var(--accent);
}
*:focus {
	outline: none;
}
a:focus-visible {
	outline: 0.125rem dashed var(--black-strong);
	outline-offset: 0.0625rem;
}
small {
	font-size: 0.75em;
	font-weight: 375;
	line-height: 133%;
}
small a:hover {
	color: var(--black-strong);
}
.preloader {
	position: fixed;
	top: 0;
	left: 0;
	width: 100vw;
	height: 100vh;
	height: 100dvh;
	background-color: var(--paper);
	display: flex;
	justify-content: center;
	align-items: center;
	z-index: var(--l-system);
	gap: 2em;
	opacity: 1;
  	transition: opacity 1s;
	pointer-events: none;
}
.preloader.hidden {
	opacity: 0;
}
.anim {
	display: inline-block;
	width: 2em;
	height: 2em;
	border: 0.25rem solid var(--charcoal);
	border-top-color: transparent;
	border-radius: 50%;
	animation: spin 1s infinite linear;
}
@keyframes spin {
	to { transform: rotate(360deg); }
}
section {
	position: relative;
	display: flex;
	flex-direction: column;
	align-items: flex-start;
	gap: 1em;
	width: max-content;
}
.button-3d {
    height: 2rem;
    display: flex;
    align-items: flex-end;
}
.button-3d.group button:nth-child(1n+2) {
	border-top-left-radius: 0;
	border-bottom-left-radius: 0;
	border-left: 0.5px solid var(--black-medium);
}
.button-3d.group button:nth-last-child(1n+2) {
	border-top-right-radius: 0;
	border-bottom-right-radius: 0;
	border-right: 0.5px solid var(--black-medium);
}
button {
	font-family: "LexendDeca", system-ui, sans-serif;
    font-size: 0.8em;
	font-weight: 550;
	line-height: 125%;
    text-transform: uppercase;
    letter-spacing: 0.0625em;
	color: var(--charcoal);
    background-color: var(--paper);
    border: none;
    border-radius: var(--sc);
    padding: 0.5em 0.75em 0.75em;
    transition: padding 0.1s ease-out, box-shadow 0.1s ease-out;
    box-shadow: var(--black-fade) 0 -0.25em 0 inset;
}
button:hover {
    padding: 0.5em 0.75em 0.5em;
    box-shadow: var(--black-fade) 0 0 0 inset;
}
button:active {
    padding: 0.75em 0.75em 0.25em;
    box-shadow: var(--black-medium) 0 0.25em 0 inset;
}
button:focus-visible {
	outline: 0.125rem dashed var(--black-strong);
	outline-offset: 0.125rem;
	z-index: var(--l-overlay);
}
button.icon {
	padding-right: 0.625em;
	padding-left: 0.625em;
}
button.icon svg {
	display: block;
	width: 0.75rem;
	height: 0.75rem;
	padding: 0.125rem;
}
button.icon svg path {
	stroke: currentColor;
}
[tags] ul {
	list-style-type: none;
	display: flex;
	flex-flow: row wrap;
	align-items: flex-start;
	gap: 0.5em;
	padding: 0.5em 0 0;
}
[tags] li, code {
    font-weight: 375;
	line-height: 125%;
    padding: 0.125em 0.25em;
	background-color: var(--black-light);
	border-radius: var(--sc);
	white-space: nowrap;
}
code {
	font-family: "LexendDeca", system-ui, sans-serif;
	display: inline-block;
	padding-top: 0;
	padding-bottom: 0;
}
.footnote {
	color: var(--black-medium);
	display: flex;
	flex-direction: column;
	gap: 1rem;
	box-sizing: border-box;
    width: 17rem;
    padding: 1rem;
}
.footnote * {
	font-size: inherit;
	line-height: inherit;
	hyphens: none;
}
[video] {
    position: relative;
}
[video]::after {
    content: "â–¶";
    position: absolute;
    font-size: 4rem;
	display: none;
	justify-content: center;
	align-items: center;
	color: var(--white);
	background-color: var(--black-medium);
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
	border-radius: var(--sd);
	pointer-events: none;
}
[video].paused::after {
    display: flex;
}
abbr[aria-label] {
	cursor: url(/artwork/help.svg) 12 12, help;
	border-bottom: 0.125em dashed var(--black-medium);
}
/* Tippy */
.tippy-box {
	font-size: 0.75em;
	font-weight: 375;
	line-height: 133%;
	padding: 0.25em 0.5em;
	color: var(--white);
  	background-color: var(--charcoal-fade);
	border-radius: var(--sc);
}
.tippy-content {
	padding: 0.25em;
}
.tippy-arrow {
	color: var(--charcoal-fade);
}
/* jsPlumb */
#plumbing {
	position: relative;
	z-index: var(--l-overlap);
}
#plumbing path {
	stroke: var(--charcoal);
	stroke-width: 7;
	stroke-linecap: round;
	stroke-linejoin: round;
}
#plumbing svg {
	fill: var(--charcoal);
	overflow: visible;
	display: block;
}
/* Annotations */
aside {
	font-family: "Whiteboard", sans-serif;
	font-weight: 400;
	font-size: 2em;
	line-height: 125%;
	word-spacing: -0.25em;
}
aside[id*="note"] {
	z-index: var(--l-overlap);
}
/* Dark mode */
.dark, #modal.dark .dialog {
	color: var(--paper);
	background-color: var(--charcoal);
}
button.dark {
	background-color: var(--charcoal-fade);
	--black-fade: var(--black-medium);
	--black-medium: var(--black-strong);
}
.dark button:focus-visible {
    outline-color: var(--paper);
}
.dark li, .dark code {
	background-color: var(--white-light);
}
@media (max-width: 480px) {
	.button-3d {
		height: 2.5rem;
	}
	button,
	button.icon {
		font-size: 1em;
	}
	button.icon svg {
		padding: 0.25rem;
	}
	.whiteboard .button-3d {
		height: 2rem;
	}
	.whiteboard button {
		font-size: 0.8em;
	}
}
</style>
<script>
// JSplumb
import { newInstance, BezierConnector } from "@jsplumb/browser-ui";
document.addEventListener("DOMContentLoaded", function() {
    const plumbingElement = document.getElementById('plumbing');
    if(plumbingElement) {
        const plumbing = newInstance({
            container: plumbingElement
        });
        // Arrow Type
        plumbing.registerConnectionType("Arrow", {
            connector: {
                type: BezierConnector.type,
                options: {
                    curviness: 250,
                },
            },
            endpoint: "Blank",
			overlays: [{
				type:"Arrow",
				options: {
					width: 32,
					length: 40,
					location: 1,
					foldback: 0.001,
				},
            }],
        });
        // Connections
        plumbing.connect({
            source: document.getElementById('note-start')!,
            target: document.getElementById('note-welcome')!,
			anchor: [
				[ 0.5, 1, 1, 0, 0, 8 ],
				[ 0, 0.2, -1, 0, -16, 0 ]
			],
            type: "Arrow",
        });
		plumbing.connect({
            source: document.getElementById('note-contact')!,
            target: document.getElementById('note-form')!,
			anchor: [
				[ 1, 0, 1, 0, 16, 64 ],
				[ 1, 0.8, 1, 0, 48, 0 ]
			],
            type: "Arrow",
        });
		plumbing.connect({
            source: document.getElementById('note-who')!,
            target: document.getElementById('who-01')!,
			anchor: [
				[ 0, 0.9, -1, 0 ],
				[ 0, 0, 0, 0, 0, -16 ]
			],
            type: "Arrow",
        });
		plumbing.connect({
            source: document.getElementById('note-why')!,
            target: document.getElementById('why-01')!,
			anchor: [
				[ 0.67, 0.3, 1, 0 ],
				[ 0, 0.3, -1, 0, 16, 0 ]
			],
            type: "Arrow",
        });
		plumbing.connect({
            source: document.getElementById('note-see')!,
            target: document.getElementById('wat-01')!,
			anchor: [
				[ 1, 0.9, 1, 0, 0, 0 ],
				[ 0, 0, -1, 0, -64, -96 ]
			],
            type: "Arrow",
        });
    }
});

// Imports
import panzoom, { PanZoom } from 'panzoom';
import tippy, { Props } from 'tippy.js';
import 'tippy.js/dist/tippy.css';

// Elements
const canvas = document.getElementById('canvas') as HTMLElement;
const inputElements = document.querySelectorAll('input, textarea, button, select, a[href]');
const zoomInButton = document.getElementById('zoomIn');
const zoomOutButton = document.getElementById('zoomOut');
const resetNavButton = document.getElementById('resetNav');
const modal = document.getElementById('modal');
const closeButton = document.getElementById('closeModal');
const pzSet = {
	x: 0,
	y: 0,
	z: 0.5,
	maxZ: 4.5,
	minZ: 0.1,
};

// Zooming
function zoom(pz: PanZoom, isZoomIn: boolean) {
	const scaleFactor = isZoomIn ? 1.1 : 0.9;
	const {width, height} = canvas.getBoundingClientRect();
	const currentTransform = pz.getTransform();
	const x = (width / 2 - currentTransform.x) / currentTransform.scale;
	const y = (height / 2 - currentTransform.y) / currentTransform.scale;
	const newZoom = currentTransform.scale * scaleFactor;
	pz.zoomAbs(x, y, newZoom);
}

// Handle inputs when Modal
function handleInputs(input: HTMLElement, pz: PanZoom, modal: HTMLElement | null) {
	const focusHandler = () => {
		pz.pause();
	};
	input.addEventListener('focus', focusHandler);
	const blurHandler = () => {
		if (modal && !modal.classList.contains('active')) {
			pz.resume();
		}
	};
	input.addEventListener('blur', blurHandler);
	const touchstartHandler = (event: Event) => event.stopPropagation();
	input.addEventListener('touchstart', touchstartHandler);

	// Remove the listeners
	return () => {
		input.removeEventListener('focus', focusHandler);
		input.removeEventListener('blur', blurHandler);
		input.removeEventListener('touchstart', touchstartHandler);
	};
}

// Create panzoom
function initPanzoom() {
	if (canvas) {

		// Options
		const pz = panzoom(canvas, {
			initialX: pzSet.x,
			initialY: pzSet.y,
			initialZoom: pzSet.z,
			maxZoom: pzSet.maxZ,
			minZoom: pzSet.minZ,
			// zoomDoubleClickSpeed: 1,
		});

		// Dynamic grid
		pz.on('transform', function() {
			const { scale } = pz.getTransform();
			const mainElement = document.querySelector('main');
			if (mainElement) {
				let newSize;
				let newDotSize;
				if (scale >= 2) {
					newSize = 8;
					newDotSize = 0.046875;
				} else if (scale >= 1) {
					newSize = 16;
					newDotSize = 0.078125;
				} else if (scale >= 0.5) {
					newSize = 32;
					newDotSize = 0.125;
				} else {
					newSize = 0; // No grid
					newDotSize = 0; // No dot
				}
				mainElement.style.backgroundSize = `${newSize}px ${newSize}px`;
				mainElement.style.backgroundImage = `radial-gradient(var(--black-light) ${newDotSize}em, transparent ${newDotSize}em)`;
			}
		});


		// Zoom keys
		zoomInButton?.addEventListener('click', () => zoom(pz, true));
		zoomOutButton?.addEventListener('click', () => zoom(pz, false));

		// Reset navigation
		resetNavButton?.addEventListener('click', function() {
			pz.moveTo(pzSet.x, pzSet.y);
  			pz.zoomAbs(pzSet.x, pzSet.y, pzSet.z);
		});

		// Handling interactables
		inputElements.forEach((input) => handleInputs(input as HTMLElement, pz, modal));

		// Zoom in when an image is clicked
		const images = document.querySelectorAll('article img');
		images.forEach((img) => {
			img.addEventListener('click', function(event) {
				event.stopPropagation();
				const rect = (event.target as HTMLElement).getBoundingClientRect();
				const x = (rect.left + rect.right) / 2;
				const y = (rect.top + rect.bottom) / 2;
				const zoomLevel = 2;
				pz.smoothZoomAbs(x, y, zoomLevel);
			});
		});
		
		// Resume panzoom when modal is closed
		closeButton?.addEventListener('click', () => pz.resume());

		// Resume panzoom on Escape key press
		document.addEventListener('keydown', (event) => {
			if (event.key === 'Escape') {
				pz.resume();
			}
		});
		
		// Resume panzoom on touch event outside of interactive elements
		document.addEventListener('touchstart', (event) => {
			const isInputFocused = Array.from(inputElements).some((input) =>
				input.contains(event.target as Node)
			);
			if (!isInputFocused) {
				pz.resume();
			}
		});
	}
}

// Initialization
window.addEventListener('load', function() {

	// Tippy
	const titles = Array.from(document.querySelectorAll<HTMLElement>(':not(section)[aria-label]'));
	titles.forEach((el) => {
		tippy(el, {
			content: el.getAttribute('aria-label') || '',
			touch: 'hold',
		} as Partial<Props>);
	});

	// Start panzoom
	initPanzoom();

	// Video control
	const videos = document.querySelectorAll('video');
	videos.forEach((video) => {
		const togglePlayPause = () => {
			if (video.parentElement) {
				if (video.paused) {
					video.play();
					video.parentElement.classList.remove('paused');
				} else {
					video.pause();
					video.parentElement.classList.add('paused');
				}
			}
		};
		// Listen for both 'click' and 'touchend' events
		video.addEventListener('click', togglePlayPause);
		video.addEventListener('touchend', togglePlayPause);
	});

	// Wait for page load
	setTimeout(function () {
		
		// Preloader
		const overlay = document.querySelector('.preloader');
		overlay?.classList.add('hidden');

		// Media captions
		const articleElements = document.querySelectorAll('article > p');
		articleElements.forEach((article) => {
		const img = article.querySelector('img');
		if (img) {
			const title = img.getAttribute('title');
			if (title) {

				// Creating the caption elements
				const titleElement = document.createElement('small');
				titleElement.textContent = title;
				img.insertAdjacentElement('afterend', titleElement);
			}
		}
		});

		// Media captions & Touch
		document.body.addEventListener('touchstart', function(event) {
			const mediaElements = document.querySelectorAll('article > p > img, article div[video] > video');
			const isMediaElement = Array.from(mediaElements).some((mediaElement) =>
				mediaElement.isEqualNode(event.target as Node)
			);

			if (!isMediaElement) {
				mediaElements.forEach((mediaElement) => {
					let smallElement: HTMLElement | null = null;
					if (mediaElement.parentElement?.getAttribute('video')) {
						smallElement = mediaElement.parentElement.nextElementSibling as HTMLElement;
					} else {
						smallElement = mediaElement.nextElementSibling as HTMLElement;
					}
					if (smallElement && smallElement.tagName.toLowerCase() === 'small') {
						smallElement.style.opacity = '1';
					}
				});
			} else {
				let smallElement: HTMLElement | null = null;
				const targetElement = event.target as HTMLElement;
				const targetParentElement = targetElement.parentElement;
				if (targetElement && targetParentElement) {
					if (targetParentElement.getAttribute('video')) {
						smallElement = targetParentElement.nextElementSibling as HTMLElement;
					} else {
						smallElement = targetElement.nextElementSibling as HTMLElement;
					}
					if (smallElement && smallElement.tagName.toLowerCase() === 'small') {
						smallElement.style.opacity = '0';
					}
				}
			}
		});

		// Hide jsPlumb debris from screen readers
		let elements = document.querySelectorAll("#plumbing svg");
			elements.forEach(element => {
			element.setAttribute("aria-hidden", "true");
		});

	// Timeout for preloader and captions
	}, 500);
});

// Instruct browser to not store scroll position
history.scrollRestoration = 'manual';
</script>